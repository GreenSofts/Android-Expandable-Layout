{
  "article": "Retrofit হচ্ছে Square এর ডেভেলপ করা একটা REST client বা network library. জাভা বা অ্যান্ড্রয়েডে এটা ব্যবহার করে খুব সহজেই নেটওয়ার্কের সাথে অর্থাৎ কোন ওয়েব সার্ভারের সাথে HTTP protocol এর মাধ্যমে কানেক্টেড হওয়া যায়। JSON ফরমেটে ডেটা আদান-প্রদানের জন্য এই লাইব্রেরিটা অতুলনীয়।\n\"+\n        \"\n\"+\n        \"আমার ডেভেলপমেন্টের শুরুর দিকে নেটওয়ার্ক কল দেয়ার কাজ করেছিলাম AsyncTask এর মাধ্যমে। এরপর পেলাম গুগলের ডেভেলপ করা Volley library'র খোঁজ। গত প্রায় বছরখানেক ধরে সবগুলো প্রোজেক্টে ভলি লাইব্রেরি ইউজ করেছি। এখন পেলাম আরো সহজে ব্যবহার উপযোগি রেট্রোফিট লাইব্রেরি। ভলিতে কাজ করার সময় JSON ডেটা পাঠানো বা রিসিভ করার সময় manually parse করা লাগতো। রেট্রোফিটের বড় একটা সুবিধা হচ্ছে এটা JSON parse করার জন্য জনপ্রিয় আর বহুল ব্যবহৃত Gson library ব্যবহার করে। তাই সার্ভারে ডেটা পাঠানোর সময় সেটাকে আপনার প্রয়োজন অনুসারে JSON বানিয়ে পাঠানোর দরকার হবে না। রিসিভ করার সময়েও আপনাকে নিজে হাতে ধরে ধরে পার্স করা লাগবে না। আপনি পাঠানোর সময় আপনার কোন একটা ক্লাসের অবজেক্টকে পাঠিয়ে দিবেন। Retrofit-ই Gson এর সহযোগিতায় সেটাকে JSON বানিয়ে সার্ভারে পাঠাবে। আবার রিসিভ করার পরে আপনি একটা সিংগেল মেথড কল করেই রেস্পন্সে পাওয়া ডেটাকে আপনার কাংক্ষিত ক্লাসের অবজেক্টে পার্স করতে পারবেন। আর ব্যবহার করাও তুলনামূলক সহজ। চলে যাচ্ছি সরাসরি প্রোজেক্টে।\n\"+\n        \"\n\"+\n        \"Problem Definition\n\"+\n        \"\n\"+\n        \"একটা Activity থাকবে। লগিন আইডি আর পাসওয়ার্ড ইনপুট দেয়ার ফিল্ড থাকবে। টেস্ট করার সুবিধার জন্য লগিন আইডি hasan আর পাসওয়ার্ড 123 ফিক্সড করে দেয়া হয়েছে। লগিন আইডি আর পাসওয়ার্ড ইনপুট দিয়ে লগিন বাটনে ক্লিক করলে সার্ভারে চলে যাবে এই আইডি-পাস। সেখানে চেক হবে আইডি-পাস ঠিক আছে কিনা। ঠিক থাকলে রেসপন্সে পাঠাবে 'Your are a valid user' আর ভুল হলে পাঠাবে 'User ID or Password is wrong'. যেহেতু এই নেটওয়ার্ক কলে পাসওয়ার্ড পাঠানো হচ্ছে তাই সিকিউরিটির একটা ব্যাপার আছে। তাই এই ডেটাগুলো পাঠানো হবে POST method এ।\n\"+\n        \"\n\"+\n        \"একই একটিভিটিতে আরেকটা টেক্সট ইনপুটের ফিল্ড থাকবে। সেখানে ইউজার আইডি হিসেবে hasan দিয়ে সাবমিট করলে সার্ভার আপনাকে একটা joke পাঠাবে। Joke টা শুধু hasan আইডি এর জন্যেই পাঠানো হবে। অন্য কোন আইডি দিলে সার্ভার রেসপন্সে পাঠাবে 'You are not a valid user'. আর এই নেটওয়ার্ক রিকোয়েস্টটা হবে GET method এ।\n\"+\n        \"\n\"+\n        \"উপরের দুইটা কাজ করার মাধ্যমে আমরা GET-POST দুইটা মেথডই শিখব।\n\"+\n        \"\n\"+\n        \"Open a project\n\"+\n        \"\n\"+\n        \"পছন্দ মত নাম দিয়ে একটা প্রোজেক্ট ওপেন করেন অ্যান্ড্রয়েড স্টুডিও ব্যবহার করে।\n\"+\n        \"\n\"+\n        \"Add Retrofit to Gradle file\n\"+\n        \"\n\"+\n        \"Retrofit আর Gson library ব্যবহার করার জন্য App level gradle ফাইলের dependencies এ অ্যাড করেন নিচের দুটি লাইনঃ\n\"+\n        \"\n\"+\n        \"compile 'com.squareup.retrofit2:retrofit:2.1.0'\n\"+\n        \"compile 'com.squareup.retrofit2:converter-gson:2.0.2'\n\"+\n        \"Sync করেন, প্রথম কাজ শেষ।\n\"+\n        \"\n\"+\n        \"Create some packages and classes\n\"+\n        \"\n\"+\n        \"retrofit-1MainActivity ছাড়াও আরো চারটা ক্লাস/ফাইল বানাতে হবে। ম্যানেজ করার সুবিধার্থে ৪ টা প্যাকেজ বানিয়ে নিয়ে পারেন ছবির মত করে। Package-গুলো হচ্ছেঃ Activity, Interface, Model ও Retrofit.\n\"+\n        \"\n\"+\n        \"Activity প্যাকেজে MainActivity-কে drag and drop করুন। এরপর বাকি প্যাকেজগুলোতে যথাক্রমে ApiInterface, ServerResponse, User ও RetrofitApiClient নামের ক্লাসগুলো create করেন।\n\"+\n        \"\n\"+\n        \"এখন একটা একটা করে ক্লাস দেখব আর বর্ণনা করব।\n\"+\n        \"\n\"+\n        \"\n\"+\n        \"\n\"+\n        \"\n\"+\n        \"\n\"+\n        \"Model classes\n\"+\n        \"\n\"+\n        \"মডেল ক্লাসের মধ্যে আমাদের ডেটাগুলো কিভাবে থাকবে না থাকবে সেটা বলা হয়েছে। Problem Definition থেকে এতক্ষণে হয়ত বুঝে গেছেন আমরা ইউজারের আইডি আর পাসওয়ার্ড ইনপুট নিচ্ছি। এটা নেটওয়ার্কে পাঠাচ্ছি। তাহলে User একটা ক্লাস হতে পারে। যার মধ্যে id, password এই ডেটাগুলো থাকবে। এই ডেটাগুলোকে হ্যান্ডেল করার জন্য দরকার হচ্ছে আমাদের User class.\n\"+\n        \"\n\"+\n        \"import com.google.gson.annotations.SerializedName;\n\"+\n        \"\n\"+\n        \"public class User {\n\"+\n        \"\n\"+\n        \"        @SerializedName(\"user_id\")\n\"+\n        \"        private String userId;\n\"+\n        \"        @SerializedName(\"password\")\n\"+\n        \"        private String password;\n\"+\n        \"\n\"+\n        \"        public User(){}\n\"+\n        \"\n\"+\n        \"        public void setUserId(String userId) {\n\"+\n        \"            this.userId = userId;\n\"+\n        \"        }\n\"+\n        \"\n\"+\n        \"        public void setPassword(String password) {\n\"+\n        \"            this.password = password;\n\"+\n        \"        }\n\"+\n        \"\n\"+\n        \"}\n\"+\n        \"সোজা-সাপটা একটা ক্লাস। দুইটা ডেটা আর দুইটা মেথড আছে। একটু কারিগরি ফলানো হয়েছে ডেটাগুলো declare করার আগের লাইনে। এইটুকু কারিগরিই আমাদের এই ক্লাসের অবজেক্টকে দরকার মত JSON বানিয়ে দিবে। যখন এই User ক্লাসের কোন অবজেক্টকে সার্ভারে পাঠাবো তখন Gson library খুঁজবে যে এই ক্লাসের ডেটাগুলোর নাম কী? সে এসে এই ক্লাসের ডেটা বা ভেরিয়েবলগুলোর নাম দিয়েই JSON key বানাবে। কিন্তু আমরা userId এরকম JSON key চাই না। আমাদের দরকার \"user_id\" এই ফরমেট। এটার জন্যেই ভেরিয়েবলের শুরুতে লিখে দেয়া হয়েছে @SerializedName(\"user_id\"). কারণ Gson library শুরুতে খুঁজে দেখে @SerializedName আছে কিনা। যদি থাকে তাহলে তার পরের ভেরিয়েবলের ডেটাকে @SerializedName এর ভিতরের string এর Key হিসেবে সার্ভারে পাঠায়।\n\"+\n        \"\n\"+\n        \"যদি @SerializedName ব্যবহার না করতাম তাহলে এই ক্লাসের অবজেক্টকে সার্ভারে পাঠানো হত এই ফরমেটেঃ\n\"+\n        \"\n\"+\n        \"{\n\"+\n        \"    \"userId\":\"hasan\",\n\"+\n        \"    \"password\":\"123\"\n\"+\n        \"}\n\"+\n        \"কিন্তু @SerializedName এর ভিতরে প্যারামিটার দিয়ে সেট করে দেয়াতে আমাদের লিখা ক্লাসের অবজেক্টকে পাঠানো হবে এই ফরমেটেঃ\n\"+\n        \"\n\"+\n        \"{\n\"+\n        \"    \"user_id\":\"hasan\",\n\"+\n        \"    \"password\":\"123\"\n\"+\n        \"}\n\"+\n        \"লাইফ অনেক সহজ হয়ে গেল তাই না? :)\n\"+\n        \"\n\"+\n        \"এ তো গেল যেই ডেটা সার্ভারে পাঠাবো তার Model. সার্ভার থেকে তো কিছু ডেটা আসবে। সেগুলোকে রিসিভ করে ফরমেট করার জন্য আরেকটা ক্লাস দরকার। সেই ক্লাসের নাম দিয়েছি ServerResponse ক্লাস।\n\"+\n        \"\n\"+\n        \"import com.google.gson.annotations.SerializedName;\n\"+\n        \"\n\"+\n        \"public class ServerResponse {\n\"+\n        \"\n\"+\n        \"        @SerializedName(\"status\")\n\"+\n        \"        boolean statusString; //variable name is statusString but it'll map with \"status\"\n\"+\n        \"        @SerializedName(\"message\")\n\"+\n        \"        String messageString; //variable name is messageString but it'll map with \"message\"\n\"+\n        \"\n\"+\n        \"        public boolean isSuccess(){\n\"+\n        \"            return statusString;\n\"+\n        \"        }\n\"+\n        \"\n\"+\n        \"        public String getMessage() {\n\"+\n        \"        return messageString;\n\"+\n        \"    }\n\"+\n        \"}\n\"+\n        \"আমরা নেটওয়ার্কে দুইটা কল করছি। একটা করছি লগিন করার জন্য অর্থাৎ POST method শেখার জন্য। আরেকটা হচ্ছে সার্ভারে আইডি পাঠিয়ে একটা কৌতুক পড়তে চাচ্ছি। এটা GET method শেখার জন্য। টিউটোরিয়ালের সাইজ ছোট করার জন্য বুদ্ধি করে দুইটা রিকোয়েস্টের রেসপন্সের ডেটা একই রেখেছি। লগিনের সময় সার্ভার আমাকে দুইটা ডেটা পাঠাবে। একটা হচ্ছে status (login successful কিনা সেটার true-false স্ট্যাটাস) আরেকটা ডেটা হচ্ছে message (status true হলে সার্ভার পাঠাবে You are a valid user আর false হলে পাঠাবে ID/Password wrong). GET request এর কৌতুক রিসিভ করার জন্যেও একই JSON KEY ব্যবহার করা হচ্ছে। আইডি সঠিক হলে সার্ভার থেকে status এ true, সাথে message এ কৌতুক পাঠানো হবে। অন্যথায় status এ false আর message এ বলা হবে Invalid User.\n\"+\n        \"\n\"+\n        \"এত কথা বলার কারণ হচ্ছে, আপনি যতগুলো সার্ভার কল করবেন তার রেসপন্সের ডেটাগুলো ভিন্ন ভিন্ন হতে পারে। সবগুলো ভিন্ন ভিন্ন JSON object এর জন্য আলাদা আলাদা response ক্লাস বানাতে হবে। এত্তগুলা ক্লাস বানাতে কষ্ট লাগবে? বানায়ে দেখেন, পরের কাজ কত্ত সোজা হয়ে যায়!\n\"+\n        \"\n\"+\n        \"এরপরেও যারা ভয় পাচ্ছেন তাদের জন্য JetBrain এর POJO Generator প্লাগিন আছে যেটা Android Studio এর সাথে এড করে ব্যবহার করতে পারবেন। এতে একটা JSON object ইনপুট দিলে আউটপুট হিসেবে Java model class পাওয়া যায়। এছাড়াও online pojo class generator রয়েছে। গুগল করলেই সব পেয়ে যাবেন।\n\"+\n        \"\n\"+\n        \"RetrofitApiClient class\n\"+\n        \"\n\"+\n        \"import com.google.gson.Gson;\n\"+\n        \"import com.google.gson.GsonBuilder;\n\"+\n        \"import retrofit2.Retrofit;\n\"+\n        \"import retrofit2.converter.gson.GsonConverterFactory;\n\"+\n        \" \n\"+\n        \"public class RetrofitApiClient {\n\"+\n        \" \n\"+\n        \"        private static final String BASE_URL = \"http://192.168.0.101\"; //address of your localhost\n\"+\n        \"        private static Retrofit retrofit = null;\n\"+\n        \" \n\"+\n        \"        private static Gson gson = new GsonBuilder()\n\"+\n        \"                .setLenient()\n\"+\n        \"                .create();\n\"+\n        \"\n\"+\n        \"\t\tprivate RetrofitApiClient() {} // So that nobody can create an object with constructor\n\"+\n        \" \n\"+\n        \"        public static synchronized Retrofit getClient() {\n\"+\n        \"            if (retrofit==null) {\n\"+\n        \"                retrofit = new Retrofit.Builder()\n\"+\n        \"                        .baseUrl(BASE_URL)\n\"+\n        \"                        .addConverterFactory(GsonConverterFactory.create(gson))\n\"+\n        \"                        .build();\n\"+\n        \"            }\n\"+\n        \"            return retrofit;\n\"+\n        \"        }\n\"+\n        \" \n\"+\n        \"}\n\"+\n        \"শুরুর BASE_URL এ আপনার পিসির localhost এর IP বসানো আছে। ইমুলেটর বা রিয়েল ডিভাইস (যদি WiFi এর সাথে কানেক্টেড থাকে) দিয়ে যেন চেক করা যায় তাই এই আইপি দেয়া। আপনার যদি রিয়েল সার্ভার থাকে তাহলে সেটার লিংক এখানে বসবে।\n\"+\n        \"\n\"+\n        \"পুরো প্রোজেক্টে Retrofit এর একটা মাত্র instance-ই তৈরি হবে। সেটা নিয়ন্ত্রিত হচ্ছে getClient() মেথডের মাধ্যমে। নেটওয়ার্ক কলের জন্য RetrofitApiClient ক্লাসের একটা মাত্র অবজেক্টই সবাই ব্যবহার করবে। খেয়াল করে দেখেন, এই ক্লাসের constructor একটা private method. একটা প্রাইভেট মেথড দিয়ে কিভাবে এই ক্লাসের অবজেক্ট বানাবো? কোন ক্লাস থেকে এই ক্লাসের অবজেক্ট বানাতে গেলে কনস্ট্রাকটর ব্যবহার করা যাবে না। বরং ব্যবহার করতে হবে getClient() এই স্ট্যাটিক মেথডটি। এই মেথডের ভিতরে চেক করা হচ্ছে এই ক্লাসেরই একটা প্রাইভেট ডেটা retrofit অবজেক্টটা null কিনা। retrofit একটা প্রাইভেট ডেটা, এটার কোন সেটারও নাই। তাই অন্যান্য ক্লাস থেকে ইচ্ছা করলেও এই ডেটাকে ইনিশিয়ালাইজ করা সম্ভব না। প্রথমবার getClient() কল হবার সময় retrofit==null সত্য হবে। সত্য হলে এর ভিতরে retrofit কে initialize করা হয়েছে। এরপর return করে দেয়া হয়েছে। পরের বার আবার যদি getClient() কল করা হয় তখন এই প্রথম বার তৈরি হওয়া instance এর রেফারেন্সটাই রিটার্ন করে দেয়া হবে। এই যে কোন একটা ক্লাসের একটা অবজেক্টই শুধু তৈরি করা যাবে এই বাধ্যবাধ্যকতার একটা গাল ভরা নাম আছে। গুরুজনেরা এটাকে Singleton Design Pattern বলে থাকেন। এই ডিজাইন প্যাটার্ন ব্যবহার করে অনেক বড় বড় হাতি-ঘোড়া মারা যায়। শুধু Singleton Design Pattern এর উপর বিস্তারিত একটা ব্লগ পোস্ট করার ইচ্ছা আছে। আপাতত এইটুকু আইডিয়া থাকলেই হবে।\n\"+\n        \"\n\"+\n        \"retrofit কে initialization এর সময় addConverterFactory() ব্যবহার করা হয়েছে যার প্যারামিটার হিসেবে দেয়া আছে ক্লাসের ভিতরে বানানো Gson ক্লাসের একটা প্রাইভেট object. এটা দিয়ে বুঝানো হয়েছে যে retrofit অবজেক্টের মাধ্যমে যত ডেটা পাঠানো হবে সেগুলো যাওয়ার আগে আমাদের মডেল ক্লাস অনুযায়ী সাইজ হয়ে যাবে। আর এই কনভার্ট বা সাইজ করার মহান দায়িত্ব পালন করতে সাহয্য করবে gson অবজেক্টটি।\n\"+\n        \"\n\"+\n        \"ApiInterface class\n\"+\n        \"\n\"+\n        \"এটা সাধারণ জাভা ক্লাস না। এটা ইন্টারফেস। আপনি ক্লাস বানানোর সময় এটা অটোমেটিক্যাল্যি পাবলিক ক্লাস হিসেবে তৈরি হয়েছিল। নিচের কোডটা কপি পেস্ট করুন আপনার এই ফাইলেঃ\n\"+\n        \"\n\"+\n        \"import retrofit2.Call;\n\"+\n        \"import retrofit2.http.Body;\n\"+\n        \"import retrofit2.http.GET;\n\"+\n        \"import retrofit2.http.POST;\n\"+\n        \"import retrofit2.http.Query;\n\"+\n        \"\n\"+\n        \"public interface ApiInterface {\n\"+\n        \"\n\"+\n        \"    @POST(\"/retrofit_get_post/server_side_code.php\")\n\"+\n        \"    Call<ServerResponse> getUserValidity(@Body User userLoginCredential);\n\"+\n        \"\n\"+\n        \"    @GET(\"/retrofit_get_post/server_side_code.php\")\n\"+\n        \"    Call<ServerResponse> getJoke(@Query(\"user_id\") String userId);\n\"+\n        \"\n\"+\n        \"}\n\"+\n        \"একটা পোস্ট আরেকটা গেট মেথড উল্লেখ করা আছে। @POST annotation এর পরে উল্লেখ করা হয়েছে সার্ভারের রাউট। Base URL আমরা RetrofitApiClient ক্লাসে উল্লেখ করেছিলাম। সেই বেজ লিংক কিন্তু সাধারণত সবগুলো কলের ক্ষেত্রে একই থাকে। যেমন বেজ লিংক হিসেবে বলা হয়েছে লোকালহোস্টের আইপি বা localhost. localhost এ ঢুকে আমি একটা ফোল্ডার বানিয়েছি retrofit_get_post নামে। এর ভিতরে একটা ফাইল ক্রিয়েট করেছি server_side_code.php নাম দিয়ে। তার মানে আমি যদি কোন রিকোয়েস্ট এই ফাইলে পাঠাতে চাই তাহলে localhost এর URL এর পরে ফাইলের path-ও বলে দিতে হবে। লোকালহোস্টের URL RetrofitApiClient এ উল্লেখ করেছি। এখানে বাকি অংশটা উল্লেখ করলাম। POST method এর ক্ষেত্রে আমাদের রিকোয়েস্টটা যাবে মূলত http://192.168.0.101/retrofit_get_post/server_side_code.php  অ্যাড্রেসে। POST, GET উভয় ক্ষেত্রেই একই রাউট দেখা যাচ্ছে। এর কারণ হচ্ছে আমি একটা PHP ফাইল দিয়েই উভয় রিকোয়েস্ট হ্যান্ডেল করেছি। আপনার পোস্ট, গেট এর ফাইল যদি আলাদা হয় তাহলে সেই অনুযায়ী রাউট বলে দিবেন।\n\"+\n        \"\n\"+\n        \"POST request এর মাধ্যমে আমরা একজন ইউজারের ভ্যালিডিটি চেক করতে চাচ্ছি। তাই @POST annotation এর পরের লাইনে মেথডের নাম দিয়েছি getUserValidity(). এতে প্যারামিটার হিসেবে পাঠানো হয়েছে User ক্লাসের একটি অবজেক্টকে। সেটার শুরুতে উল্লেখ করতে হবে @Body annotation. এতো গেল পাঠানোর কথা। সার্ভার থেকে যেটা পাঠাবে সেটা রিসিভ করতে হবে না? সেটা রিসিভ করে কোন ক্লাস অনুযায়ী JSON parse করা লাগবে? ServerResponse ক্লাস অনুযায়ী তাই না? সেটাই বলা হয়েছে getUserValidity() এর শুরুতে return type হিসাবে।\n\"+\n        \"\n\"+\n        \"দ্বিতীয় মেথডটা GET রিকোয়েস্টের জন্য। এতে প্যারামিটার হিসেবে কোন অবজেক্ট পাঠাচ্ছি না। শুধু একটা ইউজার আইডি পাঠালেই হচ্ছে তাই স্ট্রিং হিসেবে এটাকে পাঠিয়ে দিচ্ছি। @Query annotation এর ভিতরে \"user_id\" দিয়ে এরপর একটা স্ট্রিং এর অবজেক্ট userId উল্লেখ করা হয়েছে। এর মানে হচ্ছে userId স্ট্রিং অবজেক্টটা \"user_id\" এর সাথে map হবে। অর্থাৎ user_id হবে key আর userId হবে value. POST request এ URL এর সাথে ডেটা দৃশ্যমান থাকে না। কিন্তু GET request এ কিন্তু ডেটাগুলো URL এর সাথে যায়। আমার করা PHP কোড অনুযায়ী অ্যাপ থেকে গেট রিকোয়েস্টে হিট করতে হবে http://192.168.0.101/retrofit_get_post/server_side_code.php?user_id=hasan এই লিংকে। লক্ষ্য করেন, মূল লিংকের পরে ?user_id=hasan যুক্ত হয়েছে। আমার সার্ভার সাইডের কোড user_id এর ভ্যালু hasan কিনা সেটা চেক করবে। কিন্তু প্রশ্ন হচ্ছে জাভা কোডের @GET annotation এর ভিতরে কিন্তু এই টাইপের কিছুই উল্লেখ নাই, তাহলে এই লিংকে হিট করবে কেমনে? উত্তর হচ্ছে (@Query(\"user_id\") String userId), এটাই লিংকের শেষে \"?\" ও \"user_id\" যোগ করে সমান চিহ্ন দিয়ে এরপরে userId স্ট্রিং এর ভ্যালু বসায় দিবে।\n\"+\n        \"\n\"+\n        \"@Body, @Query, @Path এরকম বেশ কয়েকটা annotation আছে। গুগল করে জেনে নিবেন প্লিজ।\n\"+\n        \"\n\"+\n        \"Network call from MainActivity class\n\"+\n        \"\n\"+\n        \"MainActivity তে Interface class এর একটা instance বানাতে হবে। ক্লাসের ডেটা মেম্বার হিসেবে উল্লেখ করা যায়ঃ\n\"+\n        \"\n\"+\n        \"private ApiInterface apiInterface;\n\"+\n        \"onCreate() এর ভিতরে initialize করতে পারেন এভাবেঃ\n\"+\n        \"\n\"+\n        \"apiInterface = RetrofitApiClient.getClient().create(ApiInterface.class);\n\"+\n        \"Login এর button click event থেকে এই মেথডটা কল করে পোস্ট রিকোয়েস্ট পাঠানো হচ্ছে ও রেসপন্স রিসিভ করা হচ্ছেঃ\n\"+\n        \"\n\"+\n        \"private void checkUserValidity(User userCredential){\n\"+\n        \"\n\"+\n        \"    Call<ServerResponse> call = apiInterface.getUserValidity(userCredential);\n\"+\n        \"\n\"+\n        \"    call.enqueue(new Callback<ServerResponse>() {\n\"+\n        \"\n\"+\n        \"        @Override\n\"+\n        \"        public void onResponse(Call<ServerResponse> call, Response<ServerResponse> response) {\n\"+\n        \"\n\"+\n        \"            ServerResponse validity = response.body();\n\"+\n        \"            Toast.makeText(getApplicationContext(), validity.getMessage(), Toast.LENGTH_LONG).show();\n\"+\n        \"        }\n\"+\n        \"\n\"+\n        \"        @Override\n\"+\n        \"        public void onFailure(Call call, Throwable t) {\n\"+\n        \"            Log.e(TAG, t.toString());\n\"+\n        \"        }\n\"+\n        \"    });\n\"+\n        \"}\n\"+\n        \"সার্ভার থেকে রেসপন্স যদি ঠিকঠাক মত আসে তাহলে সেটা রিসিভ হবে onResponse() এর ভিতরে। কিন্তু যদি আপনার এখান থেকে কোন কারণে রিকোয়েস্ট সেন্ড না হয়, বা সার্ভারে কোন ঝামেলা থাকে। বা দুই দিকের data key না মিলে অথবা URL ভুল থাকে ইত্যাদি কারণে সার্ভারে রিকোয়েস্ট গিয়ে 'সহি সালামতে' ফেরত না আসলে সেটার ট্র্যাক পাবেন onFailure মেথডে। সার্ভার থেকে আসা রেসপন্সকে আমাদের ServeResponse ক্লাসের অবজেক্টে কনভার্ট করা হচ্ছে validity = resoponse.body() এই একটা মাত্র মেথড কল করার মাধ্যমে।\n\"+\n        \"\n\"+\n        \"GET request এর জন্যেও প্রায় একই ভাবে কাজ করবে এই মেথডটিঃ\n\"+\n        \"\n\"+\n        \"private void getJokeFromServer(String userId) {\n\"+\n        \"\n\"+\n        \"    Call<ServerResponse> call = apiInterface.getJoke(userId);\n\"+\n        \"\n\"+\n        \"    call.enqueue(new Callback<ServerResponse>() {\n\"+\n        \"        @Override\n\"+\n        \"        public void onResponse(Call<ServerResponse> call, Response<ServerResponse> response) {\n\"+\n        \"            ServerResponse validity = response.body();\n\"+\n        \"            jokeTextView.setText(validity.getMessage());\n\"+\n        \"        }\n\"+\n        \"\n\"+\n        \"        @Override\n\"+\n        \"        public void onFailure(Call<ServerResponse> call, Throwable t) {\n\"+\n        \"            Log.e(TAG, t.toString());\n\"+\n        \"        }\n\"+\n        \"    });\n\"+\n        \"}\n\"+\n        \"Server side PHP Code\n\"+\n        \"\n\"+\n        \"আপনার যদি লাইভ সার্ভার না থাকে সেক্ষেত্রে Xampp/Wamp এর মাধ্যমে আপনার পিসিকেই সার্ভার হিসেবে ব্যবহার করে অ্যাপটা টেস্ট করতে পারবেন। Xampp/wamp ইন্সটলের পর নির্দিষ্ট ফোল্ডারে গিয়ে retrofit_get_post নামের একটা ফোল্ডার বানান। এর ভিতরে তৈরি করুন server_side_code.php নামের একটি php file. <?php ?>  tag এর ভিতরে কপি-পেস্ট করুন নিচের কোডঃ\n\"+\n        \"\n\"+\n        \"    if ($_SERVER['REQUEST_METHOD'] === 'POST')\n\"+\n        \"    {\n\"+\n        \"        $data = file_get_contents('php://input');\n\"+\n        \"        $json_data = json_decode($data , true);\n\"+\n        \"    \n\"+\n        \"        //code to process data\n\"+\n        \"        if ($data == \"\" || empty($json_data['user_id']) || empty($json_data['password']))\n\"+\n        \"        {\n\"+\n        \"            $response = array('status' => false, 'message' => 'Invalid Values');\n\"+\n        \"        }\n\"+\n        \"        else\n\"+\n        \"        {\n\"+\n        \"            if($json_data['user_id']=='hasan' && $json_data['password']==123)\n\"+\n        \"                $response = array('status' => true, 'message' => 'Wow! You are a valid user!');\n\"+\n        \"            else\n\"+\n        \"                $response = array('status' => false, 'message' => 'User ID or password is not valid');\n\"+\n        \"        }\n\"+\n        \"    \n\"+\n        \"        echo json_encode($response);\n\"+\n        \"    }\n\"+\n        \"    else if($_SERVER['REQUEST_METHOD'] === 'GET')\n\"+\n        \"    {\n\"+\n        \"        if (empty($_GET['user_id']))\n\"+\n        \"        {\n\"+\n        \"            $response = array('status' => false, 'message' => 'Invalid Values');\n\"+\n        \"        }\n\"+\n        \"        else\n\"+\n        \"        {\n\"+\n        \"            if($_GET['user_id']=='hasan')\n\"+\n        \"                $response = array('status' => true, 'message' => 'Just read that 4,153,237 people got married last year, not to cause any trouble but shouldn\\'t that be an even number?');\n\"+\n        \"            else\n\"+\n        \"                $response = array('status' => false, 'message' => 'User ID is not valid');\n\"+\n        \"        }\n\"+\n        \"    \n\"+\n        \"        echo json_encode($response);\n\"+\n        \"    }\n\"+\n        \"\n\"+\n        \"ঠিকঠাক মত UI বানিয়ে রান করলে আশা করি কোড কাজ করবে। আমি বলা চলে অ্যান্ড্রয়েডে বিগিনার। অনেক বেস্ট প্র্যাক্টিসই জানি না। অভিজ্ঞ কারো চোখে ব্লগটা যদি পরে তাহলে কোথাও কোন পরিবর্তন-পরিবর্ধন বা পরামর্শ থাকলে অনুগ্রহ করে জানাবেন। আদৌ কিছু বুঝাতে পেরেছি কিনা সেটাও জানাবেন। কেউ যদি এই ব্লগ পড়ে প্রথম বারের রেট্রোফিট ইমপ্লিমেন্ট করে থাকেন তাহলে আপনাকে অভিনন্দন। ধন্যবাদ আমার পরিশ্রমকে সফল করার জন্য। কমেন্ট করে জানাতে ভুলবেন না যে আপনি প্রথম বারের মত রেট্রোফিট ব্যবহার করেছেন আমার ব্লগ পড়ে।\n\"+\n        \"\n\"+\n        \"পুরো প্রোজেক্টটি এক সাথে পাওয়া যাবে আমার গিটহাব রিপোজিটরিতে"
}